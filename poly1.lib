import("math.lib");

select_modulo(0) = _;
select_modulo(i) = !;

bottom_kill(N)  = par(k,N,!);
top_kill(i,N)   = par(k,N*N-(i*N-i+1)-i,!);
middle_sum(i,N) = par(k, i*N-i+1, (select_modulo(k%(N-1)))):>_;

sum_coeffs(0,1) = _;
sum_coeffs(0,N) = _,par(i,N*N-1,!);
sum_coeffs(N,N) = par(i,N*N-1,!),_;
sum_coeffs(i,N)  = bottom_kill(i), (par(k,i*N-i+1,_) : middle_sum(i,N)), top_kill(i,N);
sum_coeffs2(i,N) = top_kill(i,N),  (par(k,i*N-i+1,_) : middle_sum(i,N)), bottom_kill(i);

reverse(N) = bus(N) <: par(i,N,selector(N-1-i,N));

gen_facs(N) = par(i, N, (_<:bus(N))), bus(N) :
    interleave(N,N+1) :
    par(i, N, (bus(N), (_<:bus(N)))) :
    par(i, N, interleave(N,2)) :
    par(i,N*N,*) <:
    par(i,2*N-1,bus(N*N));
polysq_facs(N) = bus(N) <: bus(2*N) : gen_facs(N);
polysq_reverse_facs(N) = bus(2*N) : gen_facs(N);

polysq(1) = polysq_facs(1);
polysq(2) = polysq_facs(2) :
        par(i,2,sum_coeffs(i,2)),
        sum_coeffs(2,2);
polysq(N) = polysq_facs(N) :
        par(i,N,sum_coeffs(i,N)),
        par(i,N-2,sum_coeffs2(N-2-i,N)),
        sum_coeffs(N,N);

// FIXME: terrible hack until I get generic polynomial multiplication working
polysq_reverse(1) = polysq_reverse_facs(1);
polysq_reverse(2) = polysq_reverse_facs(2) :
        par(i,2,sum_coeffs(i,2)),
        sum_coeffs(2,2);
polysq_reverse(N) = polysq_reverse_facs(N) :
        par(i,N,sum_coeffs(i,N)),
        par(i,N-2,sum_coeffs2(N-2-i,N)),
        sum_coeffs(N,N);
