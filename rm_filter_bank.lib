declare name        "Regalia-Mitra Filter Bank";
declare version     "0.1";
declare author      "Marc Joliet";
declare license     "MIT";
declare copyright   "(c)Marc Joliet 2013";

import("filter.lib");
import("math.lib");
import("poly.lib");
import("filter_helpers.lib");

// Generate the coefficients Q(z) of the filter Q(z)/D(z) that is
// double-complementary to the filter P(z)/D(z).
gpq(P,D,N) = Q with {
    P_sq = P:polysqN(N);
    D_sq = (D,(D:reverseN(N))):poly_multN(N,N);
    M = 2*N-1;
    p(i) = P_sq:selector(i,M);
    d(i) = D_sq:selector(i,M);
    R = par(i,M,p(i)-d(i));
    r(i) = take(i+1,R);
    q(0) = sqrt(r(0));
    q(1) = r(1)/(2*q(0));
    q(i) = (r(i) - sum(k,i-1,(q(k+1)*q(i-k-1))))/(2*q(0));
    Q = par(i,N,q(i));
};

// Returns a 3rd order low-pass filter with a Cauer design (the same as
// lowpass3e) along with its corresponding double-*c*omplementary high-pass.
lowpass3ec(fc) = lp,hp
with {
    N = 3;
    M = N-1;

    // analog coefficients
    a11 = 0.802636764161030; // format long; poly(p(1:2)) % in octave
    a01 = 1.412270893774204;
    a02 = 0.822445908998816; // poly(p(3)) % in octave
    b21 = 0.019809144837789; // poly(z)
    b11 = 0;
    b01 = 1.161516418982696;
    w1 = 2*PI*fc;

    // generate the low-pass
    lp = tf2s(b21,b11,b01,a11,a01,w1) : tf1s(0,1,a02,w1);

    // Generate the double-complementary high-pass from the low-pass coefficients.
    // Personally, I think this is butt-ugly code, but I can't think of a better
    // way to implement this now.
    A = tf2s_coeffs(b21,b11,b01,a11,a01,w1);
    B = tf1s_coeffs(0,1,a02,w1);
    P = (B:bus(M),block(M)), (A:bus(N),block(N)) : poly_multN(M,N);
    D = (B:block(M),bus(M)), (A:block(N),bus(N)) : poly_multN(M,N);
    Q = gpq(P,D,4);
    d(i) = D:selector(i,4);
    // d(i) = take(i+1,D); // why does this not work?
    q(i) = take(i+1,Q);
    hp = iir((q(0),q(1),q(2),q(3)),(d(1),d(2),d(3)));
};

// Creates a Regalia-Mitra style double-complementary analysis filter bank.
//
// Sadly, this does not use the all-pass structure as proposed by Regalia and
// Mitra. Instead, it implements the equivalent structure using the
// double-complementary low-pass and high-pass pairs.
//
// NOTE: After processing, you might want to use the synthesis filter bank
// below, since the complete transfer function becomes invariant to changes in
// the filters (i.e., changing an edge frequency), according to Regalia-Mitra.
rm_filterbank_analyse(fe) = fb with {
    N = count(fe);
    w(i) = take(i+1,fe);
    stage(0) = _ <: lowpass3ec(w(N-1));
    next(i)  = par(j,i+1,_<:_,_):par(j,i+1,lowpass3ec(w(N-1-i))):bus(2),par(j,i,+);
    stage(i) = stage(i-1):next(i);
    fb = stage(N-1);
};

// Creates a Regalia-Mitra style double-complementary synthesis filter bank.
// See the analysis filter bank above for comments.
rm_filterbank_synthesize(fe) = fb with {
    N = count(fe);
    w(i) = take(i+1,fe);
    stage(0) = _,_:lowpass3ec(w(N-1)):-;
    prev(i)  = (_,_:lowpass3ec(w(N-1-i)):-),par(j,i,_<:lowpass3ec(w(N-1-i)):-);
    stage(i) = prev(i):stage(i-1);
    fb = stage(N-1);
};

// some demo functions
rm_filterbank_analyse_demo =
rm_filterbank_analyse((1000,2000,3000,4000,5000,6000,7000,8000));
rm_filterbank_synthesize_demo =
rm_filterbank_analyse((1000,2000,3000)):rm_filterbank_synthesize((1000,2000,3000));
